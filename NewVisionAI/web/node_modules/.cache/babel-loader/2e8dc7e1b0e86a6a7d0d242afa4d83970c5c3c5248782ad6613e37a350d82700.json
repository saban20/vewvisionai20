{"ast":null,"code":"/**\n * Authentication utilities for handling tokens and user sessions\n */// Token storage key\nconst TOKEN_KEY='newvision_auth_token';const USER_DATA_KEY='newvision_user_data';/**\n * Stores the authentication token in local storage\n * @param {string} token - JWT token to store\n */export const setToken=token=>{localStorage.setItem(TOKEN_KEY,token);};/**\n * Retrieves the authentication token from local storage\n * @returns {string|null} The stored token or null if not found\n */export const getToken=()=>{return localStorage.getItem(TOKEN_KEY);};/**\n * Removes the authentication token from local storage\n */export const removeToken=()=>{localStorage.removeItem(TOKEN_KEY);};/**\n * Stores user data in local storage\n * @param {Object} userData - User data object to store\n */export const setUserData=userData=>{localStorage.setItem(USER_DATA_KEY,JSON.stringify(userData));};/**\n * Retrieves user data from local storage\n * @returns {Object|null} The stored user data or null if not found\n */export const getUserData=()=>{const userData=localStorage.getItem(USER_DATA_KEY);return userData?JSON.parse(userData):null;};/**\n * Removes user data from local storage\n */export const removeUserData=()=>{localStorage.removeItem(USER_DATA_KEY);};/**\n * Checks if the token exists and is valid\n * @param {string} token - JWT token to check\n * @returns {boolean} True if token is valid, false otherwise\n */export const isTokenValid=token=>{if(!token)return false;try{// JWT tokens are in the format: header.payload.signature\nconst payload=token.split('.')[1];if(!payload)return false;// Decode the base64 payload\nconst base64=payload.replace(/-/g,'+').replace(/_/g,'/');const jsonPayload=decodeURIComponent(atob(base64).split('').map(c=>'%'+('00'+c.charCodeAt(0).toString(16)).slice(-2)).join(''));const{exp}=JSON.parse(jsonPayload);// Check if token is expired\nreturn exp*1000>Date.now();}catch(error){console.error('Error validating token:',error);return false;}};/**\n * Logs out the user by removing all authentication data\n */export const logout=()=>{removeToken();removeUserData();};/**\n * Logs in the user by storing token and user data\n * @param {string} token - JWT token\n * @param {Object} userData - User data\n */export const login=(token,userData)=>{setToken(token);setUserData(userData);};/**\n * Checks if user is authenticated\n * @returns {boolean} True if user is authenticated\n */export const isAuthenticated=()=>{const token=getToken();return token&&isTokenValid(token);};/**\n * Extract user ID from JWT token\n * @returns {string|null} User ID or null if not found/invalid\n */export const getUserId=()=>{try{const token=getToken();if(!token)return null;// JWT tokens are in format: header.payload.signature\n// We need to decode the payload (middle part)\nconst payload=token.split('.')[1];if(!payload)return null;// Decode the base64 payload\nconst decodedPayload=JSON.parse(atob(payload));// Extract the user ID from the token payload\n// This assumes the backend uses 'sub' or 'id' claim for the user ID\nreturn decodedPayload.sub||decodedPayload.id||null;}catch(error){console.error('Error extracting user ID from token:',error);return null;}};","map":{"version":3,"names":["TOKEN_KEY","USER_DATA_KEY","setToken","token","localStorage","setItem","getToken","getItem","removeToken","removeItem","setUserData","userData","JSON","stringify","getUserData","parse","removeUserData","isTokenValid","payload","split","base64","replace","jsonPayload","decodeURIComponent","atob","map","c","charCodeAt","toString","slice","join","exp","Date","now","error","console","logout","login","isAuthenticated","getUserId","decodedPayload","sub","id"],"sources":["/Users/saban/Desktop/New VisionAi 2.0/NewVisionAI/web/src/utils/auth.js"],"sourcesContent":["/**\n * Authentication utilities for handling tokens and user sessions\n */\n\n// Token storage key\nconst TOKEN_KEY = 'newvision_auth_token';\nconst USER_DATA_KEY = 'newvision_user_data';\n\n/**\n * Stores the authentication token in local storage\n * @param {string} token - JWT token to store\n */\nexport const setToken = (token) => {\n  localStorage.setItem(TOKEN_KEY, token);\n};\n\n/**\n * Retrieves the authentication token from local storage\n * @returns {string|null} The stored token or null if not found\n */\nexport const getToken = () => {\n  return localStorage.getItem(TOKEN_KEY);\n};\n\n/**\n * Removes the authentication token from local storage\n */\nexport const removeToken = () => {\n  localStorage.removeItem(TOKEN_KEY);\n};\n\n/**\n * Stores user data in local storage\n * @param {Object} userData - User data object to store\n */\nexport const setUserData = (userData) => {\n  localStorage.setItem(USER_DATA_KEY, JSON.stringify(userData));\n};\n\n/**\n * Retrieves user data from local storage\n * @returns {Object|null} The stored user data or null if not found\n */\nexport const getUserData = () => {\n  const userData = localStorage.getItem(USER_DATA_KEY);\n  return userData ? JSON.parse(userData) : null;\n};\n\n/**\n * Removes user data from local storage\n */\nexport const removeUserData = () => {\n  localStorage.removeItem(USER_DATA_KEY);\n};\n\n/**\n * Checks if the token exists and is valid\n * @param {string} token - JWT token to check\n * @returns {boolean} True if token is valid, false otherwise\n */\nexport const isTokenValid = (token) => {\n  if (!token) return false;\n  \n  try {\n    // JWT tokens are in the format: header.payload.signature\n    const payload = token.split('.')[1];\n    if (!payload) return false;\n    \n    // Decode the base64 payload\n    const base64 = payload.replace(/-/g, '+').replace(/_/g, '/');\n    const jsonPayload = decodeURIComponent(\n      atob(base64)\n        .split('')\n        .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\n        .join('')\n    );\n    \n    const { exp } = JSON.parse(jsonPayload);\n    \n    // Check if token is expired\n    return exp * 1000 > Date.now();\n  } catch (error) {\n    console.error('Error validating token:', error);\n    return false;\n  }\n};\n\n/**\n * Logs out the user by removing all authentication data\n */\nexport const logout = () => {\n  removeToken();\n  removeUserData();\n};\n\n/**\n * Logs in the user by storing token and user data\n * @param {string} token - JWT token\n * @param {Object} userData - User data\n */\nexport const login = (token, userData) => {\n  setToken(token);\n  setUserData(userData);\n};\n\n/**\n * Checks if user is authenticated\n * @returns {boolean} True if user is authenticated\n */\nexport const isAuthenticated = () => {\n  const token = getToken();\n  return token && isTokenValid(token);\n};\n\n/**\n * Extract user ID from JWT token\n * @returns {string|null} User ID or null if not found/invalid\n */\nexport const getUserId = () => {\n  try {\n    const token = getToken();\n    if (!token) return null;\n    \n    // JWT tokens are in format: header.payload.signature\n    // We need to decode the payload (middle part)\n    const payload = token.split('.')[1];\n    if (!payload) return null;\n    \n    // Decode the base64 payload\n    const decodedPayload = JSON.parse(atob(payload));\n    \n    // Extract the user ID from the token payload\n    // This assumes the backend uses 'sub' or 'id' claim for the user ID\n    return decodedPayload.sub || decodedPayload.id || null;\n  } catch (error) {\n    console.error('Error extracting user ID from token:', error);\n    return null;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}